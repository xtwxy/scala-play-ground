# play-scala-seed
My learning project for learning play framework.

## logging configuration

Play application uses logback as its default logging framework and disabled nearly all log outputs except log items generated by the logger named `application`.
If you don't known this 'feature', probably you consider your application is malfunctioning.

For example, you don't know Guice modules is activated when application start - eager loading, or activated by incoming requests - lazy loading. And you decide to check that by logging some information when it is actually started...and no log message you expected.

So add logging configuration and log some messages to ensure it's actually working, before rely on it for serious things.

```
<!-- https://www.playframework.com/documentation/latest/SettingsLogger -->
<configuration>

  <conversionRule conversionWord="coloredLevel" converterClass="play.api.libs.logback.ColoredLevel" />

  <appender name="FILE" class="ch.qos.logback.core.FileAppender">
    <file>${application.home:-.}/logs/application.log</file>
    <encoder>
      <pattern>%date [%level] from %logger in %thread - %message%n%xException</pattern>
    </encoder>
  </appender>

  <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    <encoder>
      <pattern>%coloredLevel %logger{15} - %message%n%xException{10}</pattern>
    </encoder>
  </appender>

  <appender name="ASYNCFILE" class="ch.qos.logback.classic.AsyncAppender">
    <appender-ref ref="FILE" />
  </appender>

  <appender name="ASYNCSTDOUT" class="ch.qos.logback.classic.AsyncAppender">
    <appender-ref ref="STDOUT" />
  </appender>

  <logger name="play" level="INFO" />
  <logger name="application" level="DEBUG" />
  <logger name="com.wincom.dcim" level="INFO" />

  <!-- Off these ones as they are annoying, and anyway we manage configuration ourselves -->
  <logger name="com.avaje.ebean.config.PropertyMapLoader" level="OFF" />
  <logger name="com.avaje.ebeaninternal.server.core.XmlConfigLoader" level="OFF" />
  <logger name="com.avaje.ebeaninternal.server.lib.BackgroundThread" level="OFF" />
  <logger name="com.gargoylesoftware.htmlunit.javascript" level="OFF" />

  <root level="WARN">
    <!--<appender-ref ref="ASYNCFILE" />-->
    <appender-ref ref="ASYNCSTDOUT" />
  </root>

</configuration>
```

## integrating with webjars and require.js

### easyUI

Don't use
```
"org.webjars.npm" % "jquery-easyui" % "1.5.21"
```
use 
```
"org.webjars.bower" % "github-com-novaeye-jquery-easyui-bower" % "1.5.0.1"
```
instead, because the former is not a qualified webjars artifact.

easyUI css cannot be loaded by reqire.js, 
at least I am not able to do that at this moment...
use the following non-modularized approach:
```
@Html(webJarsUtil.css("github-com-novaeye-jquery-easyui-bower", "themes/default/easyui.css"))
@Html(webJarsUtil.css("github-com-novaeye-jquery-easyui-bower", "themes/color.css"))
@Html(webJarsUtil.css("github-com-novaeye-jquery-easyui-bower", "themes/icon.css"))
```
add to the header/beginning of your markups, and then
```
@Html(webJarsUtil.requireJs(routes.Assets.versioned("javascripts/tree.js")))
```
semi-modularized, seems freaky?

## CSRF => Cross Site Request Forgery

easyUI causes many `CSRFs` that fails your requests.
Disable it with the following setup:
```
play {
  filters {
    disabled+=play.filters.csrf.CSRFFilter
    headers {
      frameOptions=null
      xssProtection=null
      contentTypeOptions=null
      permittedCrossDomainPolicies=null
      contentSecurityPolicy=null
      referrerPolicy=null
      protectHeaders=null
      bypassHeaders {
        X-Requested-With = "*"
        Csrf-Token = "nocheck"
      }
    }
    csrf {
      cookie.name = "CSRF-Token"
      header.name = "X-CSRF-Token"
    }
  }
}
```